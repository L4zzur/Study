Люди оплачивают покупки при помощи электронных карточек, покупают разнообразные товары в Интернет—магазинах.
Сведения о покупках накапливаются в магазинах и банках.
Поэтому появилась проблема, суть которой является отсутствие анонимности процесса покупки, т.е. информация о покупках любого человека может стать известной третьим лицам и использоваться против него.
Поэтому возникла идея разработать такие схемы электронных платежей, которые сохраняли бы анонимность покупателя в той же степени, что при расчете наличными деньгами.
Такие протоколы называются **электронными или цифровыми деньгами**.

Рассмотрим две «плохие» схемы, а затем «хорошую», чтобы было легче понять суть метода.

# Постановка задачи
Имеются три участника: банк, покупатель и магазин.
Покупатель и магазин имеют соответствующие счета в банке, и покупатель хочет купить некоторый товар в магазине.
Покупка осуществляется в виде трехступенчатого процесса:
1) покупатель снимает нужную сумму со своего счета в банке;
2) покупатель «пересылает» деньги в магазин;
3) магазин сообщает об этом в банк, соответствующая сумма денег зачисляется на счет магазина, а покупатель забирает товар (или товар ему доставляется).

# Наша цель
разработать такую схему, чтобы
• она была надежна;
• чтобы банк не знал, кто купил товар, т.е. была сохранена
анонимность обычных денег.

# Первая «плохая» схема
Схема базируется на RSA.
Банк имеет следующую информацию: секретные числа $Р$, $Q$, $c$
и открытые $N=PQ$, $$d = c^{-1} \bmod(\phi(N))$$

Допустим, покупатель решил израсходовать некоторую заранее оговоренную с банком сумму (например, 100 у.е.). Сначала рассмотрим случай, когда может использоваться «банкнота» только одного номинала (скажем, 100 у.е.).
Покупатель высылает в банк число п, которое будет номером банкноты (обычно требуется, чтобы генерировать случайное число в промежутке $[2, N — 1]$).

## Банк
Банк вычисляет число $$s = n^c (\bmod N)$$ и формирует банкноту $(n, s)$, которую возвращает покупателю, предварительно уменьшив его на счет 100 у.е.
Параметр s в банкноте — это подпись банка. Никто не может подделать подпись, так как число с секретно.
## Покупатель
Покупатель предъявляет банкноту $(n, s)$ в магазин, чтобы купить товар. Магазин отправляет эту банкноту в банк для проверки. Прежде всего, банк проверяет правильность подписи (эту проверку мог бы сделать и магазин, используя открытые ключи банка). Но кроме этого банк хранит все номера возвратившихся к нему банкнот и проверяет, нет ли числа $n$ в этом списке.
Если $n$ есть в списке, то платеж не принимается (кто-то пытается использовать банкноту повторно), и банк сообщает об этом магазину. Если же все проверки прошли успешно, то банк добавляет 100 у.е. на счет магазина, а магазин отпускает товар покупателю.

## Недостаток этой схемы 
отсутствует анонимность.
Банк, а также все, кто имеет доступ к открытым линиям связи, могут запомнить, какому покупателю соответствует число $n$, и тем самым выяснить, кто купил товар.

# Вторая «плохая» схема
Эта схема обеспечивает анонимность. Схема базируется на «слепой подписи».

## Покупатель
Снова покупатель хочет купить товар. Он генерирует число $n$, которое теперь не будет посылать в банк.
Затем он генерирует случайное число $r, (r, N) = 1$, и вычисляет число (п • rd)(modN). Число ћ покупатель отправляет в банк.

## Банк
Банк вычисляет число и отправляет S обратно покупателю (не забыв при этом снять 100 у.е. с его счета).

## Покупатель
Находит число r¯1(modN) и вычисляет 1)(modN).
Имеем т.е. мы получили подпись банка к $n$, но самого числа $n$ ни банк,
ни кто-либо другой не видел. Вычисление величины $S$ называется **«слепой подписью»**, так как реальное сообщение ($n$) подписывающий не видит и узнать не может.

Таким образом, покупатель имеет число п, которое никому не известно и никогда не передавалось по каналам связи, и подпись банка s, совпадатцую с вычисленной по формуле s nC(modN).
Покупатель формирует банкноту $(n, s)$ и действует так же, как в первой «плохой» схеме. Но теперь никто не знает, кому соответствует эта банкнота, т.е. она стала анонимной, как обычная бумажная банкнота.
Действия магазина и банка после предъявления покупателем банкноты $(n, s)$ ничем не отличается от действий, описанных в первой схеме.

## Почему же данная схема плохая?
Она имеет следующий недостаток: можно сфабриковать фальшивую банкноту, если известны хотя бы две настоящие.

Делается это так.
Пусть злоумышленник (будь то покупатель или магазин) имеет две настоящие банкноты ( [71, s1) и ((72, Я). Тогда он легко сможет изготовить фальшивую банкноту (пз, Я), вычислив числа f71f72(modN),

Действительно, т.е. s3 является правильной подписью для пз, и у банка нет никаких оснований, чтобы не принять эту фальшивую банкноту (он просто не сможет отличить ее от подлинной). Это так называемое «мультипликативное свойство» системы RSA

# «Хорошая» схема
В этой схеме устранены все недостатки первых двух.
В одном варианте такой схемы используется некоторая односторонняя функция
(f вычисляется легко, а обратная к ней функция — очень трудно).
Функция f не секретна и известна всем (покупателю, банку и магазину).

Банкнота теперь определяется как пара чисел (п, Sf), где т.е. подписывается не п, а значение f(n). Покупатель генерирует п (никому его не показывая), вычисляет f(n), подписывает в банке при помощи «слепой подписи» число f(n) и формирует банкноту (п, Sf). Эта банкнота обладает всеми хорошими свойствами, как и во второй схеме, в то же время подделать такую банкноту невозможно, так как невозможно вычислить f¯1. Для проверки подписи (т.е. подлинности банкноты) нужно вычислить f(n) и убедиться, что f(n).

Заметим, что при выборе односторонней функции нужно проявлять осторожность.
Например, функция f(n) — n2(modN), которая действительно является односторонней, не годится для рассматриваемого протокола. Банкноты, созданные с использованием такой функции, будут по-прежнему обладать мультипликативным свойством.
На практике в качестве f(n) обычно используются криптографические хеш-функции.
Все остальные действия магазина и банка остаются такими же,
как и в ранее описанных схемах.

Есть еще один, более простой, способ борьбы с мультипликативным свойством системы RSA — внесение избыточности в сообщение.
Допустим, что длина модуля Л] — 1024 бита. Такой же может быть и длина п.
Будем записывать (случайно выбираемый) номер банкноты только в младшие 512 бит п, а в старшие 512 бит п запишем некоторое фиксированное число. Это фиксированное число может нести полезную информацию, такую, как номинал банкноты и наименование банка.

Теперь банк при предъявлении ему банкноты будет обязательно проверять наличие фиксированного заголовка в параметре п и отвергать банкноту в случае его отсутствия.
Вероятность того, что при перемножении двух чисел по модулю Л] результат совпадет с ними в 512 битах пренебрежимо мала.
Поэтому получить фальшивую банкноту по формуле (П1П2)С s1s2 s3(modN) не удастся.

## Пример

— секретные параметры банка.
пусть Р = 17, Q
7, с = 77
IV = 119,
— соответствующие открытые параметры.

>[!hint] Замечание
>Для исключения возможности подделки банкнот их допустимыми номерами считаются только числа, состоящие из двух одинаковых десятичных цифр, например, 11, 77, 99.


Когда покупатель хочет получить банкноту, он вначале случайным образом выбирает ее номер (из числа допустимых).
Предположим, он выбрал п 33. Затем он находит случайное число r: (r, Ш) 1. Допустим, r 67.
Далее покупатель вычисляет 33 • 675 33 • 16 52(mod119).
Число 52 он посылает в банк.

Банк списывает со счета покупателя 100 у.е. и отправляет ему число 5277 103(mod119).
Покупатель вычисляет —1 и
67—1
103 • 16
= 16(mod119)
101(mod119)
и получает платежеспособную банкноту
(33, 101).


Эту банкноту он приносит (или посылает) в магазин, чтобы купить товар.
Магазин предъявляет банкноту в банк.
Банк делает следующие проверки:
1) номер банкноты (п 33) состоит из двух одинаковых десятичных цифр (т.е. содержит требуемую избыточность);
2) ранее банкнота с таким номером не предъявлялась;
3) подпись верна, т.е. 335 101(mod119).

Так как все проверки прошли успешно, банк зачисляет 100 у.е. (это фиксированный номинал банкноты) на счет магазина, о чем ему и сообщает. Магазин отпускает товар покупателю.

# Проблемы, возникающие в связи со схемой электронных денег
1. Независимо действующие покупатели или даже один покупатель, который не помнит номеров ранее использованных им банкнот, могут случайно сгенерировать две или более банкноты с одинаковыми номерами. по условиям протокола банк примет к оплате только одну из таких банкнот (ту, которая будет предъявлена первой). Однако, примем во внимание размеры чисел, используемых в протоколе. Если номер банкноты — число длиной 512 бит и покупатели генерируют его действительно случайным образом, то вероятность получения когда-либо двух одинаковых номеров пренебрежимо мала.
2. Проблема использования банкнот разного номинала. Решение этой проблемы возможно следующим образом. Банк заводит несколько пар $(c_i, d_i)$, обладающих свойством и объявляет, что d1 соответствует, например, 1000 у.е., ф — 500 у.е. и т.д. 
Когда покупатель запрашивает слепую подпись в банке, он дополнительно сообщает, какого номинала банкноту он хочет получить. Банк снимает с его счета сумму, равную указанному номиналу, и формирует подпись, используя соответствующее секретное число q.
Когда впоследствии банк получает подписанную банкноту, он использует для проверки подписи по очереди числа ф, ф и т.д. Если подпись оказалась верна для какого-то di, то принимается банкнота номинала. В случае, когда параметр п банкноты содержит фиксированный заголовок с указанием ее номинала, задача проверки подписи облегчается — банк сразу использует нужный ключ
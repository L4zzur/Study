# Схема простейшего протокола электронной подписи
Рассмотрим схему простейшего протокола электронной подписи, в котором используется модульное возведение в степень.
Пусть $p$ и $q$ -- большие простые числа, $n=pq$.
Пользователь А
- выбирает число $e \in Z^*_n$, взаимно простое с $$\phi(n) = (p-1)(q-1)$$
- вычисляет $d$ такое, что $ed \equiv 1 (\bmod \phi(n))$

Пусть требуется отправить сообщение $m$ (представленное двоичным числом).
Будем считать, что это сообщение не слишком велико, $m < n$ и $m$ взаимно просто с $n$.

Пользователь А вычисляет $s = m^d (\bmod n)$ и отправляет подписанное сообщение $(m,s)$.
Получатель, выбрав из справочника $n$ и $e$, вычисляет $s^e (\bmod n)$ и проверяет соотношение $$m \equiv s^e (\bmod n)$$
Если оно выполняется, сообщение принимается как подписанное, в противном случае подпись считается недействительной.

Корректность описанной схемы обусловлена теоремой Эйлера. Так как $$ed \equiv 1 (\bmod \phi(n))$$ то $$m^(ed) \equiv m (\bmod n)$$ т.е. $$(m^d)^e \equiv s^e \equiv m (\bmod n)$$

## Практический протокол электронной подписи
Из описанной схемы небольшой модификацией может быть получена схема, лежащая в основе применяемых на практике протоколов электронной подписи.
Предположим, что пользователь Б (банк) создает систему электронной подписи, которую используют его клиенты А 1, А2, АЗ и т. д.

### Банк
Банк выбирает для себя два простых числа $Р$ и $Q$ ($Р \neq Q$) и формирует модуль $N=PQ$.
Среди чисел $\{1, 2, ..., \phi(N)\}$ случайным образом выбирается число $Е$, взаимно простое с $\phi(N)$, по нему определяется число $D \leq \phi(N)$ такое, что $ED \equiv 1(\bmod \phi(N))$.

### Клиент А
Каждый клиент выбирает пару простых чисел $p$ и $q$ ($p \neq q$), формирует модуль $n=pq$ и пару чисел $e,d \leq \phi(n)$, для которых $$ed \equiv 1 (\bmod \phi(n))$$

При этом модуль банка должен быть больше модуля клиента: $$n < N$$
Модули и открытые ключи публикуются в справочнике:
Б $N, E$
А1 $n_1, e_1$
А2 $n_2, e_2$
...
Ключи $D, d_1, d_2,...$ сохраняются в секрете.

### Пересылка подписи
А: $m \rightarrow$ сообщение,
вычисляет $x =\equiv= m^d (\bmod n)$;
затем $s = x^E (\bmod N)$
$(m,s) \rightarrow$ Б.

### Проверка подписи
Б: $$y = s^D (\bmod N)$$
$$z = y^E (\bmod n)$$
Если $z = m$, подпись признается подлинной.

## Теорема 
Описанный протокол подписи корректен.

### Доказательство
$$z = y^e (\bmod N) = s^(De) (\bmod N) = (x^E)^{De} (\bmod N) = (m^d)^{EDe} (\bmod N) = m$$
так как $$ED \equiv 1 (\bmod \phi(N)), ed \equiv 1 (\bmod \phi(N))$$

## Пример
**Начальные значения:**
Б: $P=23, Q=11; N=23 \cdot 11 = 253, \phi(N)=22 \cdot 10 = 220;$
Пусть $E=31$; вычисляем $D=71$, находим $31 \cdot 71 = 2201 = 1 (\bmod 220)$;
$N=253, E=31$ публикуются.
А: $p=13, q=7, n=13 \cdot 7 = 91, \phi(n)=12 \cdot 6 = 72;$
Пусть $e = 5$; вычисляем $d=29, ed=145 \cdot 1 (\bmod 72)$, тогда $n=91, e=5$ публикуются.

### Проверка подлинности
А: $m=41$ - сообщение; $x=41^{29} (\bmod 91), x=6; s=6^{31} (\bmod 253), s=39;$
$(49;31) \rightarrow$ Б.
Б: $y=39^{71} (\bmod 253), y=6; z=6^5  (\bmod 91),$ 
$z=41$ - подписанное сообщение принято.

### Замечание
>**Требование $n < N$ является существенным.**
>При его несоблюдении "правильная" подпись может быть отвергнута.

Чтобы пояснить это, в предыдущем примере поменяем местами модули клиента и банка.
Тогда получим: $$z=82, m=41.$$
$z \neq m \Rightarrow$ подписанное сообщение не принято.

При рассмотрении описанного протокола электронной подписи возникает естественный вопрос: нельзя ли немного упростить протокол, выбрав один общий модуль $n$ для всех клиентов (при том, что ключи у всех строго индивидуальны)? Всю работу по созданию системы электронной подписи мог бы взять на себя банк.
Открытый справочник имел бы следующий вид:
Б $N, E$
А1 $n_1, e_1$
А2 $n_2, e_2$
...
Клиентам конфиденциально сообщались бы только их секретные ключи $d_i$.

Такая система оказывается, однако, нестойкой. Пользователь А, зная свои открытый ключ $e$ и секретный ключ $d$, может разложить общий модуль $n$ на множители $n=pq$ и вычислить $\phi(n)=(p-1)(q-1)$.
Это позволит ему по произвольному открытому ключу $e$; найти секретный ключ $d_i$ из уравнения $$e_id_i \equiv 1 (\bmod \phi(n))$$
Таким образом, любой пользователь системы при желании может подделать подпись любого другого пользователя.

## Алгоритм разложения на множители числа $n=pq$ при заданных $e$ и $d$ таких, что $ed \equiv 1 (\bmod \phi(n))$
Пусть $k=ed-1$. Числа $e$ и $d$ взаимно просты с четным числом $\phi(n)=(p-1)(q-1)$ и, значит, нечетны, а число $k=ed-1$ - четно.
Представим $k$ в виде произведения $$k=2^t r,$$ где $r \geq 1$, а $r$ - нечетно.
Так как $$ed \equiv 1 (\bmod \phi(n)),$$ то $k$ кратно $\phi(n)$. 
Поэтому $$g^k \equiv 1 (\bmod n)$$ для любого $g \in Z_n^*$.
Это означает, что $g^{k/2}$ - корень из единицы по модулю $n$.
По китайской теореме об остатках имеем 4 корня из единицы по модулю $n=pq$;
это числа $\pm1 (\bmod n)$ и $\pm \alpha (\bmod n)$.
где $\alpha$ определяется из системы сравнений $$\alpha \equiv 1 (\bmod p), \alpha \equiv -1 (\bmod p).$$

Рассмотрим возникающие варианты.
Если $$g^{k/2} \neq \pm1 (\bmod n),$$ то $g^{k/2} \equiv \alpha (\bmod n)$ или $g^{k/2} \equiv -\alpha (\bmod n)$.
Если $$g^{k/2} \neq 1 (\bmod n),$$ то $g^{k/4}$ при $t \geq 2$ является корнем из единицы по модулю $n$.

### Алгоритм
1) Случайным образом выбираем число д < п, отличное от выбранных ранее.
Если $(g,n) \neq 1$, то, вычислив их наибольший общий делитель, мы получим $р$ или $q$.
Если $(g,n)=1$, переходим к следующему пункту.
2) Последователь вычисляем степени $$y \equiv g^{k/2}, g^{k/4},...,g^{k/2^t} (\bmod n).$$
Если получен $y \equiv -1 (\bmod n)$, переходим к п. 1 (выбор нового $g$).
Если получен $y \neq \pm 1 (\bmod n)$, вычисляем НОД чисел $y-1$ и $n$. Он равен одному из простых делителей числа $n$.
Если получен $y \equiv 1 (\bmod n)$,  вычисляем следующее значение $y$.
Если снова $y \equiv -1 (\bmod n)$, переходим к п. 1 (выбор нового $g$).
3) Если разложение числа $n$ в п. 1 и 2 ещё не получено, переходим к п. 1 (выбор нового $g$).
Не менее половины чисел $g \in Z_n^*$ приводят к разложению числа $n$ на множители. Поэтому вероятность выбрать подходящее число $g$ быстро растет с увеличением числа проб.

#### Пример
Пусть $n=1961, e=5, d=749$.
Применяя описанный выше алгоритм, найдем разложение числа $n=1961$ на простые множители.
Имеем $$ed-1 = 5 \cdot 749 - 1 = 3744 = 117 \cdot 2^5$$
Возьмем $g=3$.
$$3^{117 \cdot 2} \equiv 295^2 \equiv 741 (\bmod 1961), 3$$
Таким образом, число $741$ — квадратный корень из $1$ по модулю $1961$. Вычисляя наибольший общий делитель, получаем: $(740,1961)=37$
Значит, $37$ — один из простых делителей числа $1961$. Делением находим второй: $1961=53 \cdot 37$.

Если бы мы начали с $g=5$, то получили бы: $$5^117 \equiv 1560 (\bmod 1961), 5^{117 \cdot 2} \equiv 1560^2 \equiv 1960 \equiv -1 (\bmod 1961).$$
Значит, нужно выбрать другое значение $g$, отличное от $5$.
